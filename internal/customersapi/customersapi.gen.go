// Package customersapi provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package customersapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// Customer defines model for Customer.
type Customer struct {

	// The timestamp the customer was created
	CreatedAt time.Time `json:"created_at"`

	// A description of the customer, with some background.
	Description *string `json:"description,omitempty"`

	// Customer identifier.
	Id string `json:"id"`

	// Labels assigned to an entity.
	Labels []string `json:"labels"`

	// The name of the customer.
	Name string `json:"name"`

	// The timestamp the customer was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// CustomersPage defines model for CustomersPage.
type CustomersPage struct {
	Customers []Customer `json:"customers"`
}

// NewCustomer defines model for NewCustomer.
type NewCustomer struct {

	// A description of the customer, with some background.
	Description *string `json:"description,omitempty"`

	// Labels assigned to an entity.
	Labels []string `json:"labels"`

	// The name of the customer.
	Name string `json:"name"`
}

// UpdatedCustomer defines model for UpdatedCustomer.
type UpdatedCustomer struct {
	// Embedded struct due to allOf(#/components/schemas/NewCustomer)
	NewCustomer
	// Embedded fields due to inline allOf schema
	Version int64 `json:"version"`
}

// CustomersParams defines parameters for Customers.
type CustomersParams struct {
	NextToken *string `json:"nextToken,omitempty"`
	MaxItems  *int    `json:"maxItems,omitempty"`
}

// NewCustomerJSONBody defines parameters for NewCustomer.
type NewCustomerJSONBody NewCustomer

// UpdateCustomerJSONBody defines parameters for UpdateCustomer.
type UpdateCustomerJSONBody UpdatedCustomer

// NewCustomerRequestBody defines body for NewCustomer for application/json ContentType.
type NewCustomerJSONRequestBody NewCustomerJSONBody

// UpdateCustomerRequestBody defines body for UpdateCustomer for application/json ContentType.
type UpdateCustomerJSONRequestBody UpdateCustomerJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get a list of customers.
	// (GET /customers)
	Customers(ctx echo.Context, params CustomersParams) error
	// Create a customer.
	// (POST /customers)
	NewCustomer(ctx echo.Context) error

	// (GET /customers/{id})
	GetCustomer(ctx echo.Context, id string) error
	// Update a customer.
	// (PUT /customers/{id})
	UpdateCustomer(ctx echo.Context, id string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// Customers converts echo context to params.
func (w *ServerInterfaceWrapper) Customers(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CustomersParams
	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "maxItems" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxItems", ctx.QueryParams(), &params.MaxItems)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxItems: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Customers(ctx, params)
	return err
}

// NewCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) NewCustomer(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewCustomer(ctx)
	return err
}

// GetCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) GetCustomer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCustomer(ctx, id)
	return err
}

// UpdateCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateCustomer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OpenId.Scopes", []string{"exitus/customer.write", "customers.admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateCustomer(ctx, id)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/customers", wrapper.Customers, m...)
	router.POST("/customers", wrapper.NewCustomer, m...)
	router.GET("/customers/:id", wrapper.GetCustomer, m...)
	router.PUT("/customers/:id", wrapper.UpdateCustomer, m...)

} // Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/9SWbXPjNBDHv4pGMMMbJ3Fz5YC86xUo5eGulPJYOszW3iS6sySfdt0kdPzdGSmOn+Lm",
	"OtC54d7FsXdX2t//v9K9TKzOrUHDJGf3kpIlagg/Twtiq9H53ylS4lTOyho5q98Ih5RbQziWkcydzdGx",
	"whCcOATG9C/g/fCrJQpWGolB54KXKJJdwhWQqEJlJOfWaZ9ApsA48iEykrzJUc4ksVNmIcuom7xf60S0",
	"noWdd8pFYqV4KchqFLeQvFk4W5h0PFREpQfaoFI0rOYKnY/FNeg88+Hx0fTZ8afPP/v8i5MXp19+9fXZ",
	"N99+98PLix8vf7r65dfffv9jqFAGt5jRfrHvw/8CiNTCYCrYCjDC1+WNr6oYdQjby1j9Ac7Bxj8b0DgM",
	"xb/p96i7o5e4ErUuBlZf5Om/xZ4BsajiH8m+jKTDt4VymMrZtWdU7a5uY9QWYmd5N3U2e/saE/ar3+2M",
	"LmCBB3jnsMBD2t+l8Q81l48dzuVMfjRpDDep3DapW7qHq7fFJvVNGXkaD5u0jUr4HEi8v9b3Yp4PWdM9",
	"AF15eQg/bzXVBgFZ9mouZ9eHobfpldF9D8wdOqqg1FZQhp8fN0tUhnHhg3tr3IXelDe96VgtdkAXpU+i",
	"zNwOdVGROLk4F7mzdypFEiBI+eY1Bia2zpuC0N2pBMd/Gr9MxaHB50QFhhQyavYlp/E0Hh3Fo2nsCdoc",
	"DeRKzuSzcTyeeqECL0MrJh1DLXBgtlwiF84IEJki9rjrEM/a9xX8l+dpy8YUajjQyCH19b1UPtfbAt1m",
	"N0lm0uCar+wb9DvaohtQpOc3FKxhfR5E3I7VsFa60HJ2FMeR1MpUTwNgbzzZ7ZwJm5/GcZgw1jCa0AfI",
	"80wlYXeT17QVTFPqMUNnO+2CALpNrXtYz7ogNSq0BreRM3mG/FDLGRbUHljBKrmlAXanYUILMKlwO4wG",
	"Vx23dgm2nbOVPhK/sOnmyXrT8WbXX+wKLPewHD05lkNEdnekh8DsWtrp4QCSMmqZa3Kv0vIdDqNWTnEL",
	"hKmwRij+hHqXoC6wM+QWsJ7punXO6zRtTfmjYY6cLP2p4D/zw6GxWTj5u4gOmfV9uOogvgZbJI/j4+GT",
	"q/46tUjCWBa4VsQ0DrCHDVYMkKtmfsdfD3tr+/V/p7W9aj0drqf3eP/g/j/6vLqw9nyOSeEUbwKPVzkG",
	"cNcS14oLqv08XjkVADRzGVKtqmtBMyt28njnrCgjuR6Bhr+tGUGuFsC4gs2oQjO6g0ylwNb5e1mWyUd+",
	"TdWFKdx5tn/iZZv2Vh29VxctUQZQZflPAAAA//8q4tg5yg4AAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
