// Package customersapi provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package customersapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// Customer defines model for Customer.
type Customer struct {

	// The timestamp the customer was created
	CreatedAt time.Time `json:"created_at"`

	// A description of the customer, with some background.
	Description *string `json:"description,omitempty"`

	// Customer identifier.
	Id string `json:"id"`

	// Labels assigned to an entity.
	Labels []string `json:"labels"`

	// The name of the customer.
	Name string `json:"name"`

	// The timestamp the customer was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// CustomersPage defines model for CustomersPage.
type CustomersPage struct {
	Customers []Customer `json:"customers"`
}

// NewCustomer defines model for NewCustomer.
type NewCustomer struct {

	// A description of the customer, with some background.
	Description *string `json:"description,omitempty"`

	// Labels assigned to an entity.
	Labels []string `json:"labels"`

	// The name of the customer.
	Name string `json:"name"`
}

// UpdatedCustomer defines model for UpdatedCustomer.
type UpdatedCustomer struct {
	// Embedded struct due to allOf(#/components/schemas/NewCustomer)
	NewCustomer
	// Embedded fields due to inline allOf schema
	Version int64 `json:"version"`
}

// CustomersParams defines parameters for Customers.
type CustomersParams struct {
	NextToken *string `json:"nextToken,omitempty"`
	MaxItems  *int    `json:"maxItems,omitempty"`
}

// NewCustomerJSONBody defines parameters for NewCustomer.
type NewCustomerJSONBody NewCustomer

// UpdateCustomerJSONBody defines parameters for UpdateCustomer.
type UpdateCustomerJSONBody UpdatedCustomer

// NewCustomerRequestBody defines body for NewCustomer for application/json ContentType.
type NewCustomerJSONRequestBody NewCustomerJSONBody

// UpdateCustomerRequestBody defines body for UpdateCustomer for application/json ContentType.
type UpdateCustomerJSONRequestBody UpdateCustomerJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get a list of customers.
	// (GET /customers)
	Customers(ctx echo.Context, params CustomersParams) error
	// Create a customer.
	// (POST /customers)
	NewCustomer(ctx echo.Context) error

	// (GET /customers/{id})
	GetCustomer(ctx echo.Context, id string) error
	// Update a customer.
	// (PUT /customers/{id})
	UpdateCustomer(ctx echo.Context, id string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// Customers converts echo context to params.
func (w *ServerInterfaceWrapper) Customers(ctx echo.Context) error {
	var err error

	ctx.Set("sigv4.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CustomersParams
	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "maxItems" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxItems", ctx.QueryParams(), &params.MaxItems)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxItems: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Customers(ctx, params)
	return err
}

// NewCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) NewCustomer(ctx echo.Context) error {
	var err error

	ctx.Set("sigv4.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewCustomer(ctx)
	return err
}

// GetCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) GetCustomer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("sigv4.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCustomer(ctx, id)
	return err
}

// UpdateCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateCustomer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("sigv4.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateCustomer(ctx, id)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/customers", wrapper.Customers, m...)
	router.POST("/customers", wrapper.NewCustomer, m...)
	router.GET("/customers/:id", wrapper.GetCustomer, m...)
	router.PUT("/customers/:id", wrapper.UpdateCustomer, m...)

} // Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+yXW3PbNhOG/woGX2a+G0qiZCdteSe7jevmpFpu09b1ZCByRSIhAQZY6hAN/3sHIMWT",
	"aMVpPZl2xnfiYReLfZ99Be6oL5NUChCoqbej2o8gYfbneaZRJqDM7wC0r3iKXArqVU+IAp1KoWFIHZoq",
	"mYJCDjbYV8AQgncMD8OvIyDIE9DIkpRgBMTfJ1wzTcpQ6tClVIlJQAOGMDAh1KG4TYF6VKPiIqS5007e",
	"XWtKGtdELlvLOWTNMSJaJkAWzP8QKpmJYNi3CA+OtIEHIJAvOSgTCxuWpLEJd8eTk9Onz7759rvp2fn3",
	"Pzy/+PGnF69ez36+ml//+va33//oWyhmC4j14WIv7X3CtOahgICgJEwQsy5uzaocIbFhBxnLG0wptjXX",
	"giXQL4p50u1Re0evYU0qLnqqz9Lg78oeM42kjL+n9rlDFXzMuIKAejdGo3J3VRudJoit8m6rbHLxHnw0",
	"1e93pmcshCN6pyyEY+zv05iLSpcnCpbUo/8b1QM3KqdtVLX0QK7OFuvUt7lj1Lh7SJtSEZMDNB7W+lWG",
	"57/MdEeANl5GhF8KpppCsDh+s6TezXHRm+rlzq4jzAqULkWpRoELfHZal8gFQmiCOzXuQ2/z2447lsX2",
	"cGFyaPAzxXE7NwUWVWgerk4txiY6AhbYHhXtptMMI6n4J2az16qk/AVsqUM3A5awT1IMWMpDhrBm2wHL",
	"MNq/t9Zzmz83q3OxlH0Sck2ms0uSKrniAWjCiOZGudo9NEplJlKDWnEfhn/aWjhadauZNlmoU/eVTtyJ",
	"Oxi7g4lrCJIpCJZy6tGToTucmEFhGNkmjFoDHUKPt10BZkoQRmKu0eBWhRjWjK62R5dBsyK7hmIJoE19",
	"U3b5YwZqWzdZwAav5QcwmyrQ6ZkIw09fcMI2l3aImrEJ2/AkS6g3dl2HJlyUVz1g3RqyCp+zm5+4rnU4",
	"KRCE7QNL05j7dnej97oAtl7qPqZXuK1loN3UqoeV17YwtR0rAb2xrOssSZjaUo9eAN4lBrJQN63U/BP0",
	"gWqbUMhmdhIhpq8AI2kknL2ZX1v1tMZIySyMziBiKy6VFWzVNBK21u9SJTdGlUxxk+u58Lx5trAGJrwn",
	"u+nbuefNmEJuVsu9uor9wysI7ZOYJYuAeQbN0cQdPx24J4OT8WiZCd+E6tGT3TTlL+1bw6kyEXwFIy5W",
	"stBIF41Ope6h+Nz+VxImAqL2QAtYt3yzzXLTwwoTAo1nMtg+GCUtl2w7HaoM8gNAxw8O6DE296fVL0d0",
	"3+xWdx/hNO2rDXe040H+GdfVjR6SBdMQECkIx//rzsG8je4FYAPdjhG317ms0jTdxBxXloB+ZE4q5jWz",
	"8dp67Wm0DesxA/8aTnsU5Bpgh566p/2nqertQIImQiKBDdeoh5/B/pFrY7pZD8PliazluXf7bfH2P+e2",
	"+BB6OHAf3ve7x+p/o/eXn5Nf7v170R+9v+P9ef+WS8AGKxbzgKHdDYtjes+3dflRZr+riptw1WS2YLzz",
	"aNYYLYtbnv8VAAD//zRzdjYuEwAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
